---
title: 计算机网络(五)    运输层
date: 2021-12-26 19:59:27
categories: "计算机网络"
keywords: 计算机网络
tags:
  - 计算机网络
---

# 计算机网络(五) 运输层

## 1. 运输层协议概述

运输层向它上面的应用层提供通信服务，它属于面向通信部份的最高层，也是用户功能中的最低层

**端到端的通信**：进程之间的通信。主机 A 的某个进程和主机 B 上的另一个进程进行通信

**网络层和运输层的区别**：**网络层是为主机之间提供逻辑通信，运输层是为应用进程之间提供端到端的逻辑通信**。

## 2. 运输层的两个主要协议

- 用户数据报协议 UDP：传送的数据单位协议是**UDP 报文**或**用户数据报**
- 传输控制协议 TCP：传送的数据单位协议是**TCP 报文段**

### 2.1 用户数据报协议 UDP

UDP 在 IP 的数据报服务之上增加的功能·

- 复用和分用的功能
- 差错检测的功能

#### 2.1.1 UDP 的主要特点

- **UDP 是无连接的**：减少了开销和发送数据之前的时延
- **UDP 尽最大努力交付**：不保证可靠交付
- **UDP 是面向报文的**：UDP 一次交付一个完整的报文
- **UDP 没有拥塞控制**
- **UDP 支持一对一、一对多、多对一、多对多的交互通信**
- **UDP 的首部开销小**，只有 8 个字节(由 4 个字段组成，每个字段都是 2 个字节)，比 TCP 的 20 个字节的首部要短

### 2.2 传输控制协议 TCP

#### 2.2.1 TCP 最主要的特点

- TCP 是<b style="color: red">面向连接</b>的运输层协议

- 每一条 TCP 连接**只能由两个端点**，每一条 TCP 连接都**只能是一对一**的

- TCP 提供<b style="color: red">可靠交付</b>的服务

- TCP 提供**全双工**通信

- **面向字节流**：流指的是流入或流出进程的字节序列

  应用程序和 TCP 的交互是一次一个数据块，但 TCP 把应用程序交下来的数据当成一连串无结构的字节流。(接收方应用程序收到的数据块和发送方应用程序发出的**数据块不一定具有对应大小的关系**，但是收到的**字节流完全一样**)

#### 2.2..2 TCP 的连接

- 每一条 TCP 连接有**两个端点**

- <b style="color: red">TCP 连接的断点叫做套接字(socket)或插口</b>

- **端口号拼接到 IP 地址就构成了套接字**，即套接字 socket=(IP 地址:端口号)

  例如，套接字 socket=(127.0.0.1:8080)

  每一条 TCP 连接**唯一**地被通信两端的**两个端点**(即两个套接字)所确定。

  例如：TCP 连接::= {socket1, socket2} = {(IP1:port1), (IP2, port2)}

**TCP 连接、IP 地址、套接字**

- TCP 连接是由协议软件提供的一种抽象
- TCP 连接的端点是个抽象的套接字，即(IP 地址:端口号)
- 同一个 IP 地址可以有多个不同的 TCP 连接
- 同一个端口号可以出现在多个不同的 TCP 连接中

### 2.3 可靠传输的工作原理

#### 2.3.1 停止等待协议

停止等待就是每发送完一个分组就停止发送，等待对方的确认，在收到确认后再发送下一个分组

![](https://s2.loli.net/2021/12/26/qZSudAFnCPUQyMN.jpg)

出现差错：

- 接收方 B 接收 M1 时检测出了差错，就丢弃 M1，不通知发送方 A 收到有差错的分组
- M1 在传输过程中丢失了

在上面两种情况下，B 都不会发送任何信息，但是 A 必须重发分组，直到 B 正确接收为止，这样才可以实现可靠通信

问题：A 如何知道 B 是否 1 正确收到了 M1?

解决方法：超时重传

1. A 为每一个已发送的分组都设置了一个**超时计时器**
2. A 只要在计时器到期之前收到了相应的确认，就撤销该超时计时器，继续发送下一个分组 M2
3. 如果 A 在超时计时器规定时间内没有收到 B 的确认，就认为分组错误或丢失，所以需要重发该分组

问题：如果分组正确到达 B 但是 B 回送的确认丢失或延迟了，A 会超时重传，B 可能会受到重发的 M1，B 如何知道收到了重复的分组，需要丢弃。

解决方法：编号

1. A 为每一个发送的分组都进行编号。如果 B 收到了编号相同的分组，则认为收到了重复分组，丢弃重复的分组，并回传确认
2. B 也为发送的确认进行编号，指示是对哪一个分组的确认
3. A 根据确认以及它的编号，可以确定它是对哪一个分组的确认，避免重发。如果是重复的确认，则将其丢弃

<b style="color: red">停止等待协议的要点：</b>

- **停止等待**：发送方每次只发送一个分组，在收到确认后 1 再发送下一个分组
- **编号**：对发送的每个分组和确认都进行编号
- **自动重传请求**：发送方为每个发送的分组设置一个超时计时器。如果发送方没有在超时计时器到期之前收到确认，则会自动重传分组
- 简单，但**信道利用率低**

#### 2.3.2 连续 ARQ 协议

- 发送方一次可以发送**多个分组**
- 使用**滑动窗口协议**控制发送方和接收方所能发送和接收的分组的数量和编号
- 每收到一个确认，发送方就把发送窗口**向前滑动**
- 采用**回退 N**方法进行重传

![](https://s2.loli.net/2021/12/26/QPXtuv5FWGSEcV4.jpg)

接收方一般采用**累计确认**的方式。即不必对收到的分组逐个发送确认，而是**对按序到达的最后一个分组发送确认**，即**到这个分组为止的所有分组都已经正确收到了**

优点：容易实现，即使确认丢失也不必重传

缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息(如发送 1, 2, 3, 4, 5, 接收方收到 1, 2, 4, 5，只能向发送方反映接收到了 1, 2 分组，不能像发送方确认正确收到 4, 5 分组)

如果发送方发送 1, 2, 3, 4, 5 分组，而中间的第三个分组丢失了，接收方只能对前两个分组发出确认，而发送方无法知道后面三个分组是否发送成功，所以只能把后面的三个分组都在重传一次，这就叫做**回退 N**，表示需要回退， 去重传已经发送过的 N 个分组

**滑动窗口协议**：ppt(p88)

![](https://s2.loli.net/2021/12/26/QEcHXNwW3q6y5jg.jpg)

### 2.4 TCP 报文段的首部格式

TCP 是面向字节流的，但是 TCP 传送的数据单元却是报文段。

一个 TCP 报文段分为首部和数据两部分。**TCP 首部的最小长度是 20 字节**

### 2.5 TCP 可靠传输的实现

#### 2.5.1 以字节为单位的滑动窗口

TCP 使用流水线传输和滑动窗口协议实现高效、可靠的传输

TCP 的滑动窗口**以字节为单位**，发送方 A 和发送方 B 分别维持一个发送窗口和一个接收窗口。

**发送窗口**在没有收到确认时，可以连续把窗口内的数据全部发送出去；**接收窗口**只允许接收落入窗口内的数据。

例子：

![](https://pic.imgdb.cn/item/61a866552ab3f51d91795cae.jpg)

**如果 A 的发送窗口内的序号都已用完，但没有收到确认，则必须停止发送。**

![](https://pic.imgdb.cn/item/61a866e02ab3f51d9179ba23.jpg)

发送方的应用进程把字节流写入 TCP 的发送缓存，接收方的应用进程从 TCP 的接收缓存中读取字节流。

**发送缓存暂时存放**：

- 准备发送的数据
- 已发送出但并未收到确认的数据

**接收缓存暂时存放**：

- 按序到达的但还没被读取的数据
- 不按序到达的数据

A 的发送窗口并不总是和 B 的接收窗口一样大。

TCP 针对不按序到达的数据的处理：

- 先临时存放在接收窗口中
- 缺少的数据到达后，再按序交付给上层的应用进程

#### 2.5.2 超时重传时间的选择

TCP 每发送一个报文段，就对这个报文段设置一次计时器。

如果计时器设置的重传时间到了，但是还没有收到确认，就要重传这一报文段。

加权平均往返时间、超时重传时间 RTO、Karn 算法

#### 2.5.3 选择确认 SACK

场景：收到的报文段没有差错，只是没按序号，中间还缺少某些序号的数据。选择确认 SACK 可以只传送缺少的数据而不重传已经正确到达接收方的数据。

### 2.6 TCP 的拥塞控制(PPT P158)

**慢开始**、**拥塞避免算法**、**快重传**

### 2.7 TCP 的连接

TCP 是面向连接的协议

TCP 连接有三个阶段：

1. **连接建立**
2. **数据传送**
3. **连接释放**

TCP 连接的建立**采用客户服务器方式**。主动发起连接建立的应用进程叫做**客户端**(client)，被动等待连接建立的应用进程叫做**服务器**(server)

#### 2.7.1 TCP 的连接建立

TCP 建立连接的过程叫做**握手**。握手需要在客户端和服务器之间交换三个 TCP 报文段，称为**三报文握手**

采用三报文握手的目的：防止已失效的连接请求报文段突然又传送到了。

![image-20211209143835954](https://raw.githubusercontent.com/13535944743/CLZ_img/master/imsges/202112091438033.png)

![image-20211209144023848](https://raw.githubusercontent.com/13535944743/CLZ_img/master/imsges/202112091440908.png)

![image-20211209144035208](https://raw.githubusercontent.com/13535944743/CLZ_img/master/imsges/202112091440266.png)

![image-20211209144049512](https://raw.githubusercontent.com/13535944743/CLZ_img/master/imsges/202112091440555.png)

![image-20211209144100735](https://raw.githubusercontent.com/13535944743/CLZ_img/master/imsges/202112091441796.png)

#### 2.7.2 TCP 的连接释放

TCP 连接释放过程是**四报文握手**

![image-20211209144315512](https://raw.githubusercontent.com/13535944743/CLZ_img/master/imsges/202112091443586.png)

![image-20211209144553920](https://raw.githubusercontent.com/13535944743/CLZ_img/master/imsges/202112091445966.png)

![image-20211209144600913](https://raw.githubusercontent.com/13535944743/CLZ_img/master/imsges/202112091446967.png)

![image-20211209144616280](https://raw.githubusercontent.com/13535944743/CLZ_img/master/imsges/202112091446336.png)
